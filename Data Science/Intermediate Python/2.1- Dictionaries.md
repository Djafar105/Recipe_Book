# Dictionaries
## Introduction : 
* In Python, a **dictionary** is a built-in data type designed for organizing data as **key–value pairs**, allowing you to access elements using a unique key rather than a numeric index like in in objects such as lists or arrays 
- A **key** acts like a label or identifier, while the **value** is the data associated with it. For example, when modeling a person, keys could be `"name"`, `"age"`, or `"height"`, each pointing to its respective value.
- example : 
	* `person = {"name": "Alice","age": 25,"height": 170}`
	* Here, `"name"`, `"age"`, and `"height"` are **keys**, while `"Alice"`, `25`, and `170` are the corresponding **values**
* you cant do this : `dict={list1_askeys,list2asvalues}` #disapointed #wonder #explanation [[#^d1ac93]]
* commands: 
	* `dict['key']`: accesses the value associated to key
	* `dict['key']=value`: add a new pair of key value to the dictionary or update if the key is allready existing
	* `del(dict['key'])`: deletes the both the key and the value associated to it 
	* `dict.keys()`: lists the keys of a dictionary
	* `dict.values()` : lists the values of a dictionary
	* `key in dict`: checks wether a key is in a dict or not 
	* 
* Questions : 
	* 1- can a dictionary be formed of dictionaries
	* 1- answer : yes , a dictionary can contain **nested dictionaries**, meaning each key maps to another dictionary as its value. In dictionaries, **only the keys must be hashable** to enable fast lookups, while the values can be any Python objects, including mutable types like lists or other dictionaries.
	*  example : `person = {"name": "Alice","details": {"age": 30,"height": 170}}`
	* 2- can a key have multiple values
## Python pause 
* **Mutable vs immutable**  : ^d1ac93
	* In Python, data types are classified into **mutable** and **immutable** based on whether their contents can be modified after creation.
	* **Immutable types** cannot be changed in place. Any operation that looks like a "modification" actually creates a new object in memory. Examples:  `int`, `float`, `bool`, `str`, `tuple`.
	* **Mutable types** allow in-place modification of their content without creating a new object. Examples:  `list`, `dict`, `set`, `array`.
		* `x = [1, 2, 3]`
		* `x[0] = 99 ` :  modifies the same list object
		or even
		* `x[0]=[1,5,4,8]`
	* Hashability and dictionaries : 
		* **Hashability is central to how dictionaries work.** Each key in a dictionary must have a fixed hash value so Python can locate it instantly — this is why only **immutable types** (e.g., strings, numbers, tuples) can serve as keys. Lists, being mutable, cannot be used as keys since their content and hash could change, breaking the dictionary's structure. In contrast, lists themselves have no such constraint: you can freely replace a list element (even a string) with another list because lists are indexed by position, not by a hash-based lookup
		* `print(hash("hello"))`   Works: strings are hashable
		* `print(hash([1, 2, 3]))`  ❌ Error: 'list' objects are unhashable
		* `my_list = ["a", "b", "c"]`
		* `my_list[0] = [1, 2, 3]`  ✅ Works, lists can store any type
	
