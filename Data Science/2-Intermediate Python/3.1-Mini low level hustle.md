# Context: Filtering Conditions on Two Houses

Suppose we have two NumPy arrays representing house areas: `my_house` and `your_house`. We want to filter elements based on multiple logical conditions — for example, find the rooms where **both houses have areas smaller than 11 m²**. While this sounds straightforward, combining boolean arrays with `np.add` revealed a subtle issue.

---

## The Problem with `np.add` on Lists and Booleans

At first, the attempt was:

```python
b1 = [my_house < 11]
b2 = [your_house < 11]
b3 = np.add(b1, b2)
```

This didn’t work as expected because:

- Wrapping boolean arrays in `[ ]` turns them into **Python lists containing arrays**, which breaks NumPy’s element-wise operations.  
- Even when using `np.add` directly on boolean arrays, the result wasn’t numerically useful (sometimes behaving like `True/False` logic rather than numeric sums).

---

## The Key Realization

NumPy treats booleans as `True/False`, not as numeric 1/0 unless explicitly cast.  
To **force numeric addition**, at least one boolean array must be cast to `int`:

```python
b1 = (my_house < 11).astype(int)
b2 = your_house < 11
b3 = np.add(b1, b2)  # Element-wise numeric addition
```

Now, `b3` contains:
- `0` → both conditions are False,
- `1` → one condition is True,
- `2` → both conditions are True.

This mask can be used to filter data:

```python
print(my_house[b3 == 2])
print(your_house[b3 == 2])
```

---

## Final Code Example

```python
import numpy as np

my_house = np.array([18.0, 20.0, 10.75, 9.50])
your_house = np.array([14.0, 24.0, 14.25, 9.0])

# my_house greater than 18.5 or smaller than 10
print(my_house[np.logical_or(my_house < 10, my_house > 18.5)])

# Both my_house and your_house smaller than 11
b1 = (my_house < 11).astype(int)
b2 = your_house < 11
b3 = np.add(b1, b2)

print(my_house[b3 == 2])   # Elements where both conditions are True
print(your_house[b3 == 2])
```

---

## Takeaway

This exercise highlights:
- **NumPy boolean arrays are powerful filters** but behave differently from numeric arrays when combined.
- Wrapping arrays in Python lists (`[array]`) breaks NumPy’s vectorized logic.
- **Casting to `int` or using logical functions (`np.logical_and`)** ensures full control over combined conditions.
