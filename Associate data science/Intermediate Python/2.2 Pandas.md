# Pandas
## Introduction 
*  **Pandas** is a Python package designed for advanced data storage and manipulation. You can think of it as **NumPy with a focus on data organization** â€” NumPy handles heavy numerical computation, while Pandas excels at structuring data in rows and columns with labels for easy access and analysis.
- A **Pandas DataFrame** is like a table:
    - **Columns** represent variables (with names as headers). 
    - **Rows** represent observations.
***
## Creating DataFrames :
* **From a dictionary**:
	* Keys become column names, and values (lists or arrays) become the column data.
	- Commands:
	```python
		import pandas as pd 
		data = {"Name": ["Alice", "Bob"], "Age": [25, 30]}
		df = pd.DataFrame(data)  : #create DataFrame from dictionary 
		df.index = ["index1","index2"] : #custom row labels
```
* **From a CSV file (comma seperated values) :**
	* Commands:
```python
		panda_frame=pd.read_csv("path_to_csv",index_col =0)`
		#read_csv is a function
		# index_col=0 in order to state that the labels are included in the csv
```
***
## DataFrame Manipulations
* **Series vs DataFrame** :
	* A **DataFrame** is essentially built from multiple **Series**, where **each column is a Series**.
    - When selecting columns, you can either get a **Series** (1D) or preserve the **DataFrame** structure (2D), depending on your syntax.
* Subsetting a DataFrame :
	* Basic classical selection of rows and columns :
	```python
		dataframe_name['column_name'] #Selects a single column as a **Series**
		dataframe_name[['column_name']] #Selects a single column but keeps the result as a **DataFrame**.
		dataframe_name[['col1', 'col2']] #Multiple columns must always be selected with `[[]]`
		dataframe_name[start:end] #Slices rows by **position**, but the header (column names) is **not part of the index**.
	```
	* Advanced Slicing with loc and iloc
		* iloc  (integer position-based selection):
			* Ignores labels and works **purely with numeric indices**.
			- Provides a **classic slicing experience**, regardless of custom row labels.
		- loc(label based selection):
			- Works with **row labels and column names**, similar to nested list slicing.
		    - When slicing by ranges, use the **labels** (row names) and not numeric positions.
			* example : 
			* `df.loc["row2":"row4", "A":"B"]``
		* When using `.iloc[row_selector, column_selector]`, the **row selector** (first argument) only specifies which rows to include and does not influence whether the output is a Series or a DataFrame. The **column selector** (second argument) is what determines the structure of the result: using a single integer index (e.g., `2`) returns a **Series** (1D), while wrapping the index in a list (e.g., `[2]`) forces the result to remain a **DataFrame** (2D), even if only one column is selected. For example, `df.iloc[2:5, 2]` returns a Series, whereas `df.iloc[2:5, [2]]` returns a DataFrame.
		